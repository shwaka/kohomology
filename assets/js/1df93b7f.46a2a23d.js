(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[583],{16:(e,n,o)=>{"use strict";o.r(n),o.d(n,{default:()=>t});const t='package com.github.shwaka.kohomology.sample\n\nimport com.github.shwaka.kohomology.dg.degree.DegreeIndeterminate\nimport com.github.shwaka.kohomology.dg.degree.MultiDegreeGroup\nimport com.github.shwaka.kohomology.free.FreeDGAlgebra\nimport com.github.shwaka.kohomology.free.monoid.Indeterminate\nimport com.github.shwaka.kohomology.specific.SparseMatrixSpaceOverRational\n\nfun main() {\n    // \\begin{degree}\n    val sphereDim = 2\n    val degreeGroup = MultiDegreeGroup(\n        listOf(\n            DegreeIndeterminate("n", sphereDim / 2),\n            DegreeIndeterminate("m", sphereDim / 2),\n        )\n    )\n    val (n, m) = degreeGroup.generatorList\n    // \\end{degree}\n\n    // \\begin{model}\n    val indeterminateList = degreeGroup.context.run {\n        listOf(\n            Indeterminate("x", 2 * n),\n            Indeterminate("y", 4 * n - 1),\n            Indeterminate("a", 2 * m),\n            Indeterminate("b", 4 * m - 1),\n        )\n    }\n    val matrixSpace = SparseMatrixSpaceOverRational\n    val sphere = FreeDGAlgebra.fromMap(matrixSpace, degreeGroup, indeterminateList) { (x, y, a, b) ->\n        mapOf(\n            y to x.pow(2),\n            b to a.pow(2),\n        )\n    }\n    // \\end{model}\n\n    // \\begin{cohomology}\n    degreeGroup.context.run {\n        println(sphere.cohomology.getBasis(0))\n        println(sphere.cohomology.getBasis(2 * n))\n        println(sphere.cohomology.getBasis(2 * m))\n        println(sphere.cohomology.getBasisForAugmentedDegree(sphereDim))\n    }\n    // \\end{cohomology}\n}\n'},1918:(e,n,o)=>{"use strict";o.r(n),o.d(n,{default:()=>t});const t='package com.github.shwaka.kohomology.sample\n\nimport com.github.shwaka.kohomology.free.FreeDGAlgebra\nimport com.github.shwaka.kohomology.free.monoid.Indeterminate\nimport com.github.shwaka.kohomology.specific.SparseMatrixSpaceOverRational\n\nfun main() {\n    // \\begin{model}\n    val n = 1\n    val matrixSpace = SparseMatrixSpaceOverRational\n\n    // define a Sullivan model of the 4n-sphere\n    val sphereIndeterminateList = listOf(\n        Indeterminate("x", 4 * n),\n        Indeterminate("y", 8 * n - 1),\n    )\n    val sphere = FreeDGAlgebra.fromMap(matrixSpace, sphereIndeterminateList) { (x, y) ->\n        mapOf(y to x.pow(2))\n    }\n\n    // define a Sullivan model of the product of two 2n-spheres\n    val sphereProductIndeterminateList = listOf(\n        Indeterminate("a1", 2 * n),\n        Indeterminate("b1", 4 * n - 1),\n        Indeterminate("a2", 2 * n),\n        Indeterminate("b2", 4 * n - 1),\n    )\n    val sphereProduct = FreeDGAlgebra.fromMap(matrixSpace, sphereProductIndeterminateList) { (a1, b1, a2, b2) ->\n        mapOf(b1 to a1.pow(2), b2 to a2.pow(2))\n    }\n    // \\end{model}\n\n    // \\begin{dgaMap}\n    val (x, y) = sphere.generatorList\n    val (a1, b1, a2, b2) = sphereProduct.generatorList\n    val valueList = sphereProduct.context.run {\n        listOf(a1 * a2, a1.pow(2) * b2)\n    }\n    val f = sphere.getDGAlgebraMap(sphereProduct, valueList)\n    sphere.context.run {\n        // This \'context\' is necessary for pow(2) and cohomologyClass()\n        println(f(x)) // a1a2\n        println(f(x.pow(2))) // a1^2a2^2\n        println(f.inducedMapOnCohomology(x.cohomologyClass())) // [a1a2]\n        println(f.inducedMapOnCohomology(x.pow(2).cohomologyClass())) // 0\n    }\n    // \\end{dgaMap}\n}\n'},3354:(e,n,o)=>{"use strict";o.d(n,{_:()=>t});const t="https://github.com/shwaka/kohomology/blob/main"},4075:(e,n,o)=>{"use strict";o.r(n),o.d(n,{default:()=>t});const t='package com.github.shwaka.kohomology.sample\n\nimport com.github.shwaka.kohomology.free.FreeDGAlgebra\nimport com.github.shwaka.kohomology.free.monoid.Indeterminate\nimport com.github.shwaka.kohomology.specific.SparseMatrixSpaceOverRational\n\nfun main() {\n    // \\begin\n    val indeterminateList = listOf(\n        Indeterminate("a", 2),\n        Indeterminate("b", 2),\n        Indeterminate("x", 3),\n        Indeterminate("y", 3),\n        Indeterminate("z", 3)\n    )\n    val matrixSpace = SparseMatrixSpaceOverRational\n    val freeDGAlgebra = FreeDGAlgebra.fromMap(matrixSpace, indeterminateList) { (a, b, x, y, z) ->\n        mapOf(\n            // da = 0\n            // db = 0\n            x to a.pow(2), // dx = a^2\n            y to a * b,    // dy = ab\n            z to b.pow(2), // dz = b^2\n        )\n    }\n    for (degree in 0 until 10) {\n        val basis = freeDGAlgebra.cohomology.getBasis(degree)\n        println("H^$degree = Q$basis")\n    }\n    // \\end\n}\n'},4368:(e,n,o)=>{"use strict";o.r(n),o.d(n,{default:()=>t});const t='package com.github.shwaka.kohomology.sample\n\nimport com.github.shwaka.kohomology.free.FreeDGAlgebra\nimport com.github.shwaka.kohomology.free.monoid.Indeterminate\nimport com.github.shwaka.kohomology.model.FreeLoopSpace\nimport com.github.shwaka.kohomology.specific.SparseMatrixSpaceOverRational\n\nfun main() {\n    // \\begin{sphere}\n    // Define the Sullivan model of the 4-sphere.\n    val sphereDim = 4\n    val indeterminateList = listOf(\n        Indeterminate("x", sphereDim),\n        Indeterminate("y", sphereDim * 2 - 1)\n    )\n    val matrixSpace = SparseMatrixSpaceOverRational\n    val sphere = FreeDGAlgebra.fromMap(matrixSpace, indeterminateList) { (x, y) ->\n        mapOf(y to x.pow(2)) // dx = 0, dy = x^2\n    }\n    // \\end{sphere}\n\n    // \\begin{freeLoopSpace}\n    // Define the Sullivan model of the free loop space.\n    val freeLoopSpace = FreeLoopSpace(sphere)\n    val (x, y, sx, sy) = freeLoopSpace.generatorList\n    // \\end{freeLoopSpace}\n\n    // \\begin{computation}\n    // Assert that d(sy) and -2*x*sx are the same.\n    freeLoopSpace.context.run {\n        println("dsy = ${d(sy)} = ${-2 * x * sx}")\n    }\n\n    // Compute cohomology of the free loop space.\n    for (degree in 0 until 25) {\n        val basis = freeLoopSpace.cohomology.getBasis(degree)\n        println("H^$degree(LS^$sphereDim) = Q$basis")\n    }\n    // \\end{computation}\n\n    // \\begin{freeLoopSpaceWithMultiDegree}\n    val freeLoopSpaceWithMultiDegree = FreeLoopSpace.withShiftDegree(sphere)\n    for (degree in 0 until 25) {\n        val basis = freeLoopSpace.cohomology.getBasis(degree)\n        println("H^$degree(LS^$sphereDim) = Q$basis")\n    }\n    // \\end{freeLoopSpaceWithMultiDegree}\n}\n'},4658:(e,n,o)=>{var t={"./DGAlgebraMap.kt":1918,"./FreeLoopSpace.kt":4368,"./MultiDegree.kt":16,"./PrintTex.kt":8481,"./SphereModel.kt":8255,"./TopPageExample.kt":4075};function a(e){var n=r(e);return o(n)}function r(e){if(!o.o(t,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return t[e]}a.keys=function(){return Object.keys(t)},a.resolve=r,e.exports=a,a.id=4658},6176:(e,n,o)=>{"use strict";o.d(n,{F:()=>u});var t=o(3354),a=o(3748);o(6540);const r={};var i=o(4848);function s({href:e,linkTitle:n,...o}){return(0,i.jsxs)("div",{className:r.MyCodeBlock,children:[null!==e&&(0,i.jsx)("a",{href:e,target:"_blank",rel:"noreferrer",children:null!==n?n:e}),(0,i.jsx)(a.A,{...o,children:o.children})]})}const l={error:"error_c9xe"};function p(e){const n=e.map((e=>function(e){if(""===e)return 1/0;const n=new RegExp("^ *"),o=e.match(n);if(null===o)throw new Error("This can't happen");return o[0].length}(e))),o=Math.min(...n);return e.map((e=>e.substring(o)))}function m(e,n){return!0===n?new RegExp(`// \\\\${e}`):new RegExp(`// \\\\${e}{${n}}`)}function c(e,n){if(void 0===n)return{text:e};const o=m("begin",n),t=m("end",n);return function(e,n,o){const t=e.findIndex((e=>e.match(n))),a=e.findIndex((e=>e.match(o)));return-1===t||-1===a?null:{text:p(e.slice(t+1,a)).join("\n"),begin:t+2,end:a}}(e.split("\n"),o,t)}const h=o(4658);function d(e){return e.startsWith("./")?e:"./"+e}const g=new Map(h.keys().map((e=>[d(e),h(e).default])));function u(e){const n=`${t._}/website/sample/src/main/kotlin/${e.path}`,o=g.get(d(e.path));if(void 0===o)return(0,i.jsx)("div",{children:`Invalid path: ${e.path}`});const a=c(o,e.restrict);if(null===a)return(0,i.jsx)("div",{className:e.className,children:(0,i.jsxs)("div",{className:l.error,children:["ERROR: ",(0,i.jsx)("code",{children:e.restrict})," is not found in ",(0,i.jsx)("a",{href:n,children:n})]})});const r=function(e){return"begin"in e}(a)?`${n}#L${a.begin}-L${a.end}`:n;return(0,i.jsx)("div",{className:e.className,children:(0,i.jsx)(s,{className:"language-kotlin",href:r,linkTitle:e.path,children:a.text})})}},8255:(e,n,o)=>{"use strict";o.r(n),o.d(n,{default:()=>t});const t='package com.github.shwaka.kohomology.sample\n\nimport com.github.shwaka.kohomology.free.FreeDGAlgebra\nimport com.github.shwaka.kohomology.free.monoid.Indeterminate\nimport com.github.shwaka.kohomology.specific.SparseMatrixSpaceOverRational\n\nfun main() {\n    // \\begin{def}\n    val n = 2\n    // Declare an indeterminate (generator) for the free commutative graded algebra \u039b(x,y)\n    val indeterminateList = listOf(\n        Indeterminate("x", 2 * n),\n        Indeterminate("y", 4 * n - 1),\n    )\n    val matrixSpace = SparseMatrixSpaceOverRational\n    // Sullivan algebra can be defined by using the function FreeDGAlgebra.fromMap.\n    // The last argument is a function\n    // which receives the list of generators and returns the map representing the differential.\n    val sphere = FreeDGAlgebra.fromMap(matrixSpace, indeterminateList) { (x, y) ->\n        mapOf(\n            y to x.pow(2),    // x.pow(2) represents x^2\n        )\n        // If you want, you can write dx = 0 explicitly in the code\n        // by using zeroGVector, a special element that represents zero in any degree.\n        // mapOf(\n        //     x to zeroGVector,\n        //     y to x.pow(2),\n        // )\n    }\n    // \\end{def}\n\n    // \\begin{cohomology}\n    for (degree in 0 until 10) {\n        val basis = sphere.cohomology.getBasis(degree)\n        println("H^$degree(S^${2 * n}) = Q$basis")\n    }\n    // \\end{cohomology}\n\n    // \\begin{context}\n    val (x, y) = sphere.generatorList\n\n    // You can\'t write DGA operations here.\n\n    sphere.context.run {\n        // You can write DGA operations in "context.run"\n        println("d(x * y) = ${d(x * y)}")\n        println(d(x).isZero())\n        println(x.cohomologyClass())\n        println(x.pow(2).cohomologyClass())\n    }\n    // \\end{context}\n}\n'},8481:(e,n,o)=>{"use strict";o.r(n),o.d(n,{default:()=>t});const t='package com.github.shwaka.kohomology.sample\n\nimport com.github.shwaka.kohomology.free.FreeDGAlgebra\nimport com.github.shwaka.kohomology.free.monoid.Indeterminate\nimport com.github.shwaka.kohomology.model.CopiedNamePrintConfig\nimport com.github.shwaka.kohomology.model.FreeLoopSpace\nimport com.github.shwaka.kohomology.model.ShowShift\nimport com.github.shwaka.kohomology.specific.SparseMatrixSpaceOverRational\nimport com.github.shwaka.kohomology.util.PrintType\nimport com.github.shwaka.kohomology.util.Printer\n\nfun main() {\n    // \\begin{def}\n    val indeterminateList = listOf(\n        Indeterminate("a", 2),\n        Indeterminate("b", 2),\n        Indeterminate("x", 3),\n        Indeterminate("y", 3),\n        Indeterminate("z", 3),\n    )\n    val matrixSpace = SparseMatrixSpaceOverRational\n    val freeDGAlgebra = FreeDGAlgebra.fromMap(matrixSpace, indeterminateList) { (a, b, x, y, z) ->\n        mapOf(\n            x to a.pow(2),\n            y to a * b,\n            z to b.pow(2),\n        )\n    }\n    val freeLoopSpace = FreeLoopSpace(freeDGAlgebra)\n    // \\end{def}\n\n    println("----- plain output -----")\n    // \\begin{plain}\n    for (degree in 0..4) {\n        val basis = freeLoopSpace.cohomology.getBasis(degree)\n        println("H^$degree(LX) = Q$basis")\n    }\n    // \\end{plain}\n\n    println("----- tex output -----")\n    // \\begin{tex}\n    val p = Printer(printType = PrintType.TEX) {\n        register(CopiedNamePrintConfig(ShowShift.BAR))\n    }\n    for (degree in 0..4) {\n        val basis = freeLoopSpace.cohomology.getBasis(degree)\n        println("H^{$degree}(LX) &= \\\\Q${basis.map { v -> p(v) }} \\\\\\\\")\n    }\n    // \\end{tex}\n\n    println("----- long tex output -----")\n    // \\begin{long}\n    val p2 = Printer(printType = PrintType.TEX, beforeSign = "\\n") {\n        register(CopiedNamePrintConfig(ShowShift.BAR))\n    }\n    for (degree in 0..6) {\n        val basis = freeLoopSpace.cohomology.getBasis(degree)\n        val basisString = basis.joinToString(",\\n") { v -> p2(v) }\n        println("\\\\begin{autobreak}\\nH^{$degree}(LX) = \\\\Q[\\n${basisString}]\\n\\\\end{autobreak}\\\\\\\\")\n    }\n    // \\end{long}\n}\n'},8501:(e,n,o)=>{"use strict";o.r(n),o.d(n,{default:()=>x});var t=o(8774),a=o(4586),r=o(3748),i=o(6944);function s(e){var n,o,t="";if("string"==typeof e||"number"==typeof e)t+=e;else if("object"==typeof e)if(Array.isArray(e))for(n=0;n<e.length;n++)e[n]&&(o=s(e[n]))&&(t&&(t+=" "),t+=o);else for(n in e)e[n]&&(t&&(t+=" "),t+=n);return t}const l=function(){for(var e,n,o=0,t="";o<arguments.length;)(e=arguments[o++])&&(n=s(e))&&(t&&(t+=" "),t+=n);return t};var p=o(6540);const m={features:"features_xdhU",featureSvg:"featureSvg__8YW"};var c=o(4848);const h=[{title:"Compute cohomology efficiently",description:(0,c.jsxs)(p.Fragment,{children:["Kohomology can compute the cohomology of a Sullivan algebra. Since it can be done with ",(0,c.jsx)(t.A,{href:"https://en.wikipedia.org/wiki/Sparse_matrix",children:"sparse matrices"}),", we can compute complicated examples."]})},{title:"DGA morphisms",description:(0,c.jsx)(p.Fragment,{children:"Kohomology can also compute DGA morphisms, especially from Sullivan algebras. Derivations on Sullivan algebras are also supported."})},{title:"Kotlin multiplatform library",description:(0,c.jsxs)(p.Fragment,{children:["Kohomology is a ",(0,c.jsx)(t.A,{href:"https://kotlinlang.org/",children:"Kotlin"})," ",(0,c.jsx)(t.A,{href:"https://kotlinlang.org/docs/multiplatform.html",children:"multiplatform"})," library. You can use it in any Kotlin program. There is also an online ",(0,c.jsx)(t.A,{href:"./calculator",children:"Calculator"})," powered by ",(0,c.jsx)(t.A,{href:"https://kotlinlang.org/docs/js-overview.html",children:"Kotlin/JS"}),"."]})}];function d({title:e,description:n}){return(0,c.jsx)("div",{className:l("col col--4"),children:(0,c.jsxs)("div",{className:"text--center padding-horiz--md",children:[(0,c.jsx)("h3",{children:e}),(0,c.jsx)("p",{children:n})]})})}function g(){return(0,c.jsx)("section",{className:m.features,children:(0,c.jsx)("div",{className:"container",children:(0,c.jsx)("div",{className:"row",children:h.map(((e,n)=>(0,c.jsx)(d,{...e},n)))})})})}var u=o(6176);const f={heroBanner:"heroBanner_qdFl",buttons:"buttons_AeoN",exampleColumnContainer:"exampleColumnContainer_lTjZ",exampleColumn:"exampleColumn_aMtc"};function b(){const{siteConfig:e}=(0,a.A)();return(0,c.jsx)("header",{className:l("hero hero--primary",f.heroBanner),children:(0,c.jsxs)("div",{className:"container",children:[(0,c.jsx)("h1",{className:"hero__title",children:e.title}),(0,c.jsx)("p",{className:"hero__subtitle",children:e.tagline}),(0,c.jsx)("div",{className:f.buttons,children:(0,c.jsx)(t.A,{className:"button button--secondary button--lg",to:"/docs/intro",children:"Documentation"})})]})})}function x(){const{siteConfig:e}=(0,a.A)();return(0,c.jsxs)(i.A,{title:`${e.title}`,description:"A library to compute the cohomology of Sullivan algebras",children:[(0,c.jsx)(b,{}),(0,c.jsxs)("main",{children:[(0,c.jsx)(g,{}),(0,c.jsxs)("div",{className:f.exampleColumnContainer,children:[(0,c.jsx)(u.F,{path:"TopPageExample.kt",restrict:!0,className:l("col col--4",f.exampleColumn)}),(0,c.jsxs)("div",{className:l("col col--4",f.exampleColumn),children:["This code prints:",(0,c.jsx)(r.A,{children:"H^0 = Q[[1]]\nH^1 = Q[]\nH^2 = Q[[a], [b]]\nH^3 = Q[]\nH^4 = Q[]\nH^5 = Q[[- ay + bx], [- az + by]]\nH^6 = Q[]\nH^7 = Q[[- a^2z + aby]]\nH^8 = Q[]\nH^9 = Q[]"})]})]})]})]})}}}]);