(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[237],{6333:function(e,n,t){var a={"./FreeLoopSpace.kt":3632,"./PrintTex.kt":6229,"./SphereModel.kt":5125,"./TopPageExample.kt":7219};function r(e){var n=o(e);return t(n)}function o(e){if(!t.o(a,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return a[e]}r.keys=function(){return Object.keys(a)},r.resolve=o,e.exports=r,r.id=6333},2829:function(e,n,t){"use strict";t.d(n,{C:function(){return f}});var a=t(102),r=t(254),o=t(7294),i={},l=["href","linkTitle"];function s(e){var n=e.href,t=e.linkTitle,s=(0,a.Z)(e,l);return o.createElement("div",{className:i.MyCodeBlock},null!==n&&o.createElement("a",{href:n,target:"_blank",rel:"noreferrer"},null!==t?t:n),o.createElement(r.Z,s,s.children))}var c="error_c9xe";function m(e){var n=e.map((function(e){return function(e){if(""===e)return 1/0;var n=new RegExp("^ *"),t=e.match(n);if(null===t)throw new Error("This can't happen");return t[0].length}(e)})),t=Math.min.apply(Math,n);return e.map((function(e){return e.substring(t)}))}function p(e,n){return!0===n?new RegExp("// "+e):new RegExp("// "+e+" +"+n)}function u(e,n){if(void 0===n)return{text:e};var t=p("start",n),a=p("end",n);return function(e,n,t){var a=e.findIndex((function(e){return e.match(n)})),r=e.findIndex((function(e){return e.match(t)}));return-1===a||-1===r?null:{text:m(e.slice(a+1,r)).join("\n"),start:a+2,end:r}}(e.split("\n"),t,a)}var h=t(6333);function d(e){return e.startsWith("./")?e:"./"+e}var g=new Map(h.keys().map((function(e){return[d(e),h(e).default]})));function f(e){var n="https://github.com/shwaka/kohomology/blob/main/sample/src/main/kotlin/"+e.path,t=g.get(d(e.path));if(void 0===t)return o.createElement("div",null,"Invalid path: "+e.path);var a=u(t,e.restrict);if(null===a)return o.createElement("div",{className:e.className},o.createElement("div",{className:c},"ERROR: ",o.createElement("code",null,e.restrict)," is not found in ",o.createElement("a",{href:n},n)));var r=function(e){return"start"in e}(a)?n+"#L"+a.start+"-L"+a.end:n;return o.createElement("div",{className:e.className},o.createElement(s,{className:"language-kotlin",href:r,linkTitle:e.path},a.text))}},8368:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return x}});var a=t(9960),r=t(2263),o=t(2600),i=t(6010),l=t(7294),s=t(254),c=t(3117),m="features_xdhU",p=[{title:"Efficient computation",description:l.createElement(l.Fragment,null,"Kohomology supports computation with ",l.createElement(a.Z,{href:"https://en.wikipedia.org/wiki/Sparse_matrix"},"sparse matrices"),". This enables us to compute complicated examples.")},{title:"Powered by Kotlin",description:l.createElement(l.Fragment,null,"Kohomology is a ",l.createElement(a.Z,{href:"https://kotlinlang.org/"},"Kotlin")," library. You can use it in any Kotlin program. There is also an online ",l.createElement(a.Z,{href:"./calculator"},"Calculator")," powered by ",l.createElement(a.Z,{href:"https://kotlinlang.org/docs/js-overview.html"},"Kotlin/JS"),".")},{title:"Output LaTeX code",description:l.createElement(l.Fragment,null,"Kohomology can print LaTeX source code. It is useful to visualize comlicated computation result as highly readable equations typeset by LaTeX.")}];function u(e){var n=e.title,t=e.description;return l.createElement("div",{className:(0,i.Z)("col col--4")},l.createElement("div",{className:"text--center padding-horiz--md"},l.createElement("h3",null,n),l.createElement("p",null,t)))}function h(){return l.createElement("section",{className:m},l.createElement("div",{className:"container"},l.createElement("div",{className:"row"},p.map((function(e,n){return l.createElement(u,(0,c.Z)({key:n},e))})))))}var d=t(2829),g="heroBanner_qdFl",f="buttons_AeoN",b="exampleColumnContainer_lTjZ",v="exampleColumn_aMtc";function y(){var e=(0,r.Z)().siteConfig;return l.createElement("header",{className:(0,i.Z)("hero hero--primary",g)},l.createElement("div",{className:"container"},l.createElement("h1",{className:"hero__title"},e.title),l.createElement("p",{className:"hero__subtitle"},e.tagline),l.createElement("div",{className:f},l.createElement(a.Z,{className:"button button--secondary button--lg",to:"/docs/intro"},"Tutorial"))))}function x(){var e=(0,r.Z)().siteConfig;return l.createElement(o.Z,{title:""+e.title,description:"Description will go into a meta tag in <head />"},l.createElement(y,null),l.createElement("main",null,l.createElement(h,null),l.createElement("div",{className:b},l.createElement(d.C,{path:"TopPageExample.kt",restrict:!0,className:(0,i.Z)("col col--4",v)}),l.createElement("div",{className:(0,i.Z)("col col--4",v)},"This code prints:",l.createElement(s.Z,null,"H^0 = Q[[1]]\nH^1 = Q[]\nH^2 = Q[[a], [b]]\nH^3 = Q[]\nH^4 = Q[]\nH^5 = Q[[- ay + bx], [- az + by]]\nH^6 = Q[]\nH^7 = Q[[- a^2z + aby]]\nH^8 = Q[]\nH^9 = Q[]")))))}},3632:function(e,n,t){"use strict";t.r(n),n.default='package com.github.shwaka.kohomology.sample\n\nimport com.github.shwaka.kohomology.free.FreeDGAlgebra\nimport com.github.shwaka.kohomology.free.monoid.Indeterminate\nimport com.github.shwaka.kohomology.model.FreeLoopSpace\nimport com.github.shwaka.kohomology.specific.SparseMatrixSpaceOverRational\n\nfun main() {\n    // start\n    // Define the Sullivan model of the 4-sphere.\n    val sphereDim = 4\n    val indeterminateList = listOf(\n        Indeterminate("x", sphereDim),\n        Indeterminate("y", sphereDim * 2 - 1)\n    )\n    val matrixSpace = SparseMatrixSpaceOverRational\n    val sphere = FreeDGAlgebra(matrixSpace, indeterminateList) { (x, y) ->\n        listOf(zeroGVector, x.pow(2)) // dx = 0, dy = x^2\n    }\n\n    // Define the Sullivan model of the free loop space.\n    val freeLoopSpace = FreeLoopSpace(sphere)\n    val (x, y, sx, sy) = freeLoopSpace.gAlgebra.generatorList\n\n    // Assert that d(sy) and -2*x*sx are the same.\n    freeLoopSpace.context.run {\n        println("dsy = ${d(sy)} = ${-2 * x * sx}")\n    }\n\n    // Compute cohomology of the free loop space.\n    for (degree in 0 until 25) {\n        val basis = freeLoopSpace.cohomology.getBasis(degree)\n        println("H^$degree(LS^$sphereDim) = Q$basis")\n    }\n    // end\n}\n'},6229:function(e,n,t){"use strict";t.r(n),n.default='package com.github.shwaka.kohomology.sample\n\nimport com.github.shwaka.kohomology.free.FreeDGAlgebra\nimport com.github.shwaka.kohomology.free.monoid.Indeterminate\nimport com.github.shwaka.kohomology.model.FreeLoopSpace\nimport com.github.shwaka.kohomology.specific.SparseMatrixSpaceOverRational\nimport com.github.shwaka.kohomology.util.PrintType\nimport com.github.shwaka.kohomology.util.Printer\nimport com.github.shwaka.kohomology.util.ShowShift\n\nfun main() {\n    // start def\n    val indeterminateList = listOf(\n        Indeterminate("a", 2),\n        Indeterminate("b", 2),\n        Indeterminate("x", 3),\n        Indeterminate("y", 3),\n        Indeterminate("z", 3)\n    )\n    val matrixSpace = SparseMatrixSpaceOverRational\n    val freeDGAlgebra = FreeDGAlgebra(matrixSpace, indeterminateList) { (a, b, x, y, z) ->\n        listOf(zeroGVector, zeroGVector, a.pow(2), a * b, b.pow(2))\n    }\n    val freeLoopSpace = FreeLoopSpace(freeDGAlgebra)\n    // end def\n\n    println("----- plain output -----")\n    // start plain\n    for (degree in 0..4) {\n        val basis = freeLoopSpace.cohomology.getBasis(degree)\n        println("H^$degree(LX) = Q$basis")\n    }\n    // end plain\n\n    println("----- tex output -----")\n    // start tex\n    val p = Printer(printType = PrintType.TEX, showShift = ShowShift.BAR)\n    for (degree in 0..4) {\n        val basis = freeLoopSpace.cohomology.getBasis(degree)\n        println("H^{$degree}(LX) &= \\\\Q${basis.map { v -> p(v) }} \\\\\\\\")\n    }\n    // end tex\n\n    println("----- long tex output -----")\n    // start long\n    val p2 = Printer(printType = PrintType.TEX, beforeSign = "\\n", showShift = ShowShift.BAR)\n    for (degree in 0..6) {\n        val basis = freeLoopSpace.cohomology.getBasis(degree)\n        val basisString = basis.joinToString(",\\n") { v -> p2(v) }\n        println("\\\\begin{autobreak}\\nH^{$degree}(LX) = \\\\Q[\\n${basisString}]\\n\\\\end{autobreak}\\\\\\\\")\n    }\n    // end long\n}\n'},5125:function(e,n,t){"use strict";t.r(n),n.default='package com.github.shwaka.kohomology.sample\n\nimport com.github.shwaka.kohomology.free.FreeDGAlgebra\nimport com.github.shwaka.kohomology.free.monoid.Indeterminate\nimport com.github.shwaka.kohomology.specific.SparseMatrixSpaceOverRational\n\nfun main() {\n    // start def\n    val n = 2\n    // Declare an indeterminate (generator) for the free commutative graded algebra \u039b(x,y)\n    val indeterminateList = listOf(\n        Indeterminate("x", 2 * n),\n        Indeterminate("y", 4 * n - 1),\n    )\n    val matrixSpace = SparseMatrixSpaceOverRational\n    // Sullivan algebra can be defined by using the constructor of FreeDGAlgebra.\n    // The last argument is a function\n    // which receives list of generators and returns the list of the values of the differential.\n    val sphere = FreeDGAlgebra(matrixSpace, indeterminateList) { (x, y) ->\n        // zeroGVector is a special element that represents zero in any degree.\n        val dx = zeroGVector\n        // x.pow(2) represents x^2\n        val dy = x.pow(2)\n        listOf(dx, dy)\n    }\n    // end def\n\n    // start cohomology\n    for (degree in 0 until 10) {\n        val basis = sphere.cohomology.getBasis(degree)\n        println("H^$degree(S^${2 * n}) = Q$basis")\n    }\n    // end cohomology\n\n    // start context\n    val (x, y) = sphere.gAlgebra.generatorList\n\n    // You can\'t write DGA operations here.\n\n    sphere.context.run {\n        // You can write DGA operations in "context.run"\n        println("d(x * y) = ${d(x * y)}")\n        println(d(x).isZero())\n        println(x.cohomologyClass())\n        println(x.pow(2).cohomologyClass())\n    }\n    // end context\n}\n'},7219:function(e,n,t){"use strict";t.r(n),n.default='package com.github.shwaka.kohomology.sample\n\nimport com.github.shwaka.kohomology.free.FreeDGAlgebra\nimport com.github.shwaka.kohomology.free.monoid.Indeterminate\nimport com.github.shwaka.kohomology.specific.SparseMatrixSpaceOverRational\n\nfun main() {\n    // start\n    val indeterminateList = listOf(\n        Indeterminate("a", 2),\n        Indeterminate("b", 2),\n        Indeterminate("x", 3),\n        Indeterminate("y", 3),\n        Indeterminate("z", 3)\n    )\n    val matrixSpace = SparseMatrixSpaceOverRational\n    val sphere = FreeDGAlgebra(matrixSpace, indeterminateList) { (a, b, x, y, z) ->\n        val da = zeroGVector // da = 0\n        val db = zeroGVector // db = 0\n        val dx = a.pow(2) // dx = a^2\n        val dy = a * b // dy = ab\n        val dz = b.pow(2) // dz = b^2\n        listOf(da, db, dx, dy, dz)\n    }\n    for (degree in 0 until 10) {\n        val basis = sphere.cohomology.getBasis(degree)\n        println("H^$degree = Q$basis")\n    }\n    // end\n}\n'}}]);