package com.github.shwaka.kohomology.free

import com.github.shwaka.kohomology.dg.Boundedness
import com.github.shwaka.kohomology.dg.degree.IntDegree
import com.github.shwaka.kohomology.forAll
import com.github.shwaka.kohomology.free.monoid.Indeterminate
import com.github.shwaka.kohomology.free.monoid.StringIndeterminateName
import com.github.shwaka.kohomology.linalg.Matrix
import com.github.shwaka.kohomology.linalg.MatrixSpace
import com.github.shwaka.kohomology.linalg.NumVector
import com.github.shwaka.kohomology.linalg.Scalar
import com.github.shwaka.kohomology.specific.SparseMatrixSpaceOverRational
import com.github.shwaka.kohomology.util.pow
import io.kotest.assertions.throwables.shouldNotThrowAny
import io.kotest.core.spec.style.FreeSpec
import io.kotest.core.spec.style.freeSpec
import io.kotest.matchers.booleans.shouldBeFalse
import io.kotest.matchers.booleans.shouldBeTrue
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe

private fun <S : Scalar, V : NumVector<S>, M : Matrix<S, V>> noGeneratorTest(matrixSpace: MatrixSpace<S, V, M>) = freeSpec {
    "NCFreeGAlgebra should work well even when the list of generator is empty" {
        val indeterminateList = listOf<Indeterminate<IntDegree, StringIndeterminateName>>()
        val ncFreeGAlgebra = shouldNotThrowAny {
            NCFreeGAlgebra(matrixSpace, indeterminateList)
        }
        ncFreeGAlgebra[0].dim shouldBe 1
        ncFreeGAlgebra.boundedness shouldBe Boundedness(upperBound = 0, lowerBound = 0)
    }
}

private fun <S : Scalar, V : NumVector<S>, M : Matrix<S, V>> twoGeneratorTest(matrixSpace: MatrixSpace<S, V, M>) = freeSpec {
    "test with NCFreeGAlgebra generated by two indeterminates" - {
        val indeterminateList = listOf(
            Indeterminate("x", 1),
            Indeterminate("y", 1),
        )
        val ncFreeGAlgebra = NCFreeGAlgebra(matrixSpace, indeterminateList)
        val (x, y) = ncFreeGAlgebra.generatorList

        "dimension at degree n should be 2^n" {
            (0..10).forAll { n ->
                ncFreeGAlgebra[n].dim shouldBe 2.pow(n)
            }
        }

        "dimension at negative degree should be 0" {
            (-10..-1).forAll { n ->
                ncFreeGAlgebra[n].dim shouldBe 0
            }
        }

        "ncFreeGAlgebra.generatorList should be [x, y]" {
            x.toString() shouldBe "x"
            y.toString() shouldBe "y"
        }

        ncFreeGAlgebra.context.run {
            "x*y should be xy" {
                (x * y).toString() shouldBe "xy"
            }

            "x*y should not be y*x" {
                (x * y) shouldNotBe (y * x)
            }

            "x^2 should not be 0" {
                x.pow(2).isZero().shouldBeFalse()
            }
        }
    }
}

private fun <S : Scalar, V : NumVector<S>, M : Matrix<S, V>> idealTest(matrixSpace: MatrixSpace<S, V, M>) = freeSpec {
    "test the quotient T(x,y)/(xy-yx)" - {
        val indeterminateList = listOf(
            Indeterminate("x", 1),
            Indeterminate("y", 1),
        )
        val ncFreeGAlgebra = NCFreeGAlgebra(matrixSpace, indeterminateList)
        val (x, y) = ncFreeGAlgebra.generatorList
        val ideal = ncFreeGAlgebra.context.run {
            ncFreeGAlgebra.getIdeal(listOf(x * y - y * x))
        }
        val quotientGAlgebra = ncFreeGAlgebra.getQuotientByIdeal(ideal)
        val proj = quotientGAlgebra.projection

        "should have the same dim as polynomial ring" {
            (0..10).forAll { n ->
                quotientGAlgebra[n].dim shouldBe (n + 1)
            }
        }

        val a = proj(x)
        val b = proj(y)

        quotientGAlgebra.context.run {
            "x*y and y*x should be same in quotientGAlgebra" {
                (a * b) shouldBe (b * a)
            }

            "projection should be surjective" {
                (0..10).forAll { n ->
                    proj[n].isSurjective().shouldBeTrue()
                }
            }
        }
    }
}

class NCFreeGAlgebraTest : FreeSpec({
    val matrixSpace = SparseMatrixSpaceOverRational

    include(noGeneratorTest(matrixSpace))
    include(twoGeneratorTest(matrixSpace))
    include(idealTest(matrixSpace))
})
