package com.github.shwaka.kohomology.free.monoid

import com.github.shwaka.kohomology.dg.Boundedness
import com.github.shwaka.kohomology.forAll
import com.github.shwaka.kohomology.util.Sign
import io.kotest.assertions.throwables.shouldNotThrowAny
import io.kotest.assertions.throwables.shouldThrow
import io.kotest.core.spec.style.FreeSpec
import io.kotest.matchers.booleans.shouldBeFalse
import io.kotest.matchers.booleans.shouldBeTrue
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.property.Arb
import io.kotest.property.arbitrary.negativeInts
import io.kotest.property.arbitrary.positiveInts
import io.kotest.property.checkAll

class NCFreeGMonoidTest : FreeSpec({
    tags(gMonoidTag)

    "empty indeterminate list should be allowed" {
        shouldNotThrowAny {
            NCFreeGMonoid<StringIndeterminateName>(emptyList())
        }
    }

    "indeterminate list with mixed degrees is not allowed" {
        checkAll(Arb.positiveInts(), Arb.negativeInts()) { positiveDegree, negativeDegree ->
            val indeterminateList = listOf(
                Indeterminate("x", positiveDegree),
                Indeterminate("y", negativeDegree)
            )
            shouldThrow<IllegalArgumentException> {
                NCFreeGMonoid(indeterminateList)
            }
        }
    }

    "degree 0 is not allowed" {
        val indeterminateList = listOf(
            Indeterminate("x", 0)
        )
        shouldThrow<IllegalArgumentException> {
            NCFreeGMonoid(indeterminateList)
        }
    }

    "positive degrees should be allowed" {
        val indeterminateList = listOf(
            Indeterminate("x", 1),
            Indeterminate("x", 2),
            Indeterminate("x", 3),
        )
        val monoid = NCFreeGMonoid(indeterminateList)
        shouldNotThrowAny {
            monoid.listElements(0)
        }
    }

    "negative degrees should be allowed" {
        val indeterminateList = listOf(
            Indeterminate("x", -1),
            Indeterminate("x", -2),
            Indeterminate("x", -3),
        )
        val monoid = NCFreeGMonoid(indeterminateList)
        shouldNotThrowAny {
            monoid.listElements(0)
        }
    }

    "isCommutative should be true if the number of indeterminate is at most 1" {
        (0..10).forAll { n ->
            val indeterminateList = (0 until n).map {
                Indeterminate("x$n", 2)
            }
            val monoid = NCFreeGMonoid(indeterminateList)
            if (n <= 1) {
                monoid.isCommutative.shouldBeTrue()
            } else {
                monoid.isCommutative.shouldBeFalse()
            }
        }
    }

    "should be bounded below and above by 0 if indeterminate list is empty" {
        val monoid = NCFreeGMonoid<StringIndeterminateName>(emptyList())
        monoid.boundedness shouldBe Boundedness(upperBound = 0, lowerBound = 0)
    }

    "should be bounded below if generated by positive degrees" {
        val indeterminateList = listOf(
            Indeterminate("x", 2),
            Indeterminate("y", 3),
        )
        val monoid = NCFreeGMonoid(indeterminateList)
        monoid.boundedness shouldBe Boundedness(upperBound = null, lowerBound = 0)
    }

    "should be bounded only below even if generated by positive odd degrees" {
        val indeterminateList = listOf(
            Indeterminate("y", 3),
        )
        val monoid = NCFreeGMonoid(indeterminateList)
        monoid.boundedness shouldBe Boundedness(upperBound = null, lowerBound = 0)
    }

    "should be bounded above if generated by negative degrees" {
        val indeterminateList = listOf(
            Indeterminate("x", -2),
            Indeterminate("y", -3),
        )
        val monoid = NCFreeGMonoid(indeterminateList)
        monoid.boundedness shouldBe Boundedness(upperBound = 0, lowerBound = null)
    }

    "should be bounded only above even if generated by negative odd degrees" {
        val indeterminateList = listOf(
            Indeterminate("y", -3),
        )
        val monoid = NCFreeGMonoid(indeterminateList)
        monoid.boundedness shouldBe Boundedness(upperBound = 0, lowerBound = null)
    }

    "multiplication test" {
        val indeterminateList = listOf(
            Indeterminate("x", 1),
            Indeterminate("y", 1),
            Indeterminate("z", 2),
        )
        val (a, b, c) = indeterminateList
        val monoid = NCFreeGMonoid(indeterminateList)
        val x = NCMonomial(indeterminateList, listOf(a))
        val y = NCMonomial(indeterminateList, listOf(b))
        // val z = NCMonomial(indeterminateList, listOf(c))
        val xy = NCMonomial(indeterminateList, listOf(a, b))
        val yx = NCMonomial(indeterminateList, listOf(b, a))
        val xz = NCMonomial(indeterminateList, listOf(a, c))
        val xzx = NCMonomial(indeterminateList, listOf(a, c, a))
        monoid.multiply(x, y) shouldBe Signed(xy, Sign.PLUS)
        monoid.multiply(y, x) shouldNotBe monoid.multiply(x, y)
        monoid.multiply(y, x) shouldBe Signed(yx, Sign.PLUS)
        monoid.multiply(x, x) shouldNotBe Zero
        monoid.multiply(xz, x) shouldBe Signed(xzx, Sign.PLUS)
    }
})
