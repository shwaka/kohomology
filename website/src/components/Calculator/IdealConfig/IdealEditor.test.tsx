import { render, renderHook, act, screen, fireEvent, waitFor } from "@testing-library/react"
import React, { useState } from "react"
import { IdealEditor } from "./IdealEditor"
import { useIdealEditor, UseIdealEditorArgs } from "./useIdealEditor"
import { ExhaustivityError } from "@site/src/utils/ExhaustivityError"
import userEvent from "@testing-library/user-event"

describe("IdealEditor", () => {
  test("empty text as generator", async () => {
    const closeDialog = jest.fn()
    const hookArgs: UseIdealEditorArgs = {
      idealJson: "[]",
      setIdealJson: jest.fn(),
      validateGenerator: jest.fn().mockResolvedValue(true),
      validateGeneratorArray: jest.fn().mockResolvedValue(true),
    }
    const { result } = renderHook(() => useIdealEditor(hookArgs))
    const { rerender } = render(
      <IdealEditor
        {...result.current.idealEditorPropsExceptOnSubmit}
        onSubmit={result.current.getOnSubmit(closeDialog)}
      />
    )

    act(() => {
      result.current.idealEditorPropsExceptOnSubmit.append({ text: "" })
    })
    rerender(
      <IdealEditor
        {...result.current.idealEditorPropsExceptOnSubmit}
        onSubmit={result.current.getOnSubmit(closeDialog)}
      />
    )
    await act(async () => {
      await result.current.getOnSubmit(jest.fn())()
    })
    rerender(
      <IdealEditor
        {...result.current.idealEditorPropsExceptOnSubmit}
        onSubmit={result.current.getOnSubmit(closeDialog)}
      />
    )

    expect(screen.getByRole("alert")).toContainHTML("Please enter the generator.")
  })
})

type TestContainerProps = {
  useIdealEditorArgs: Omit<UseIdealEditorArgs, "idealJson" | "setIdealJson">
  closeDialog: () => void
}
export function IdealEditorTestContainer(
  { useIdealEditorArgs, closeDialog }: TestContainerProps
): React.JSX.Element {
  const [idealJson, setIdealJson] = useState("[]")
  const { idealEditorPropsExceptOnSubmit, getOnSubmit } = useIdealEditor({
    ...useIdealEditorArgs,
    idealJson, setIdealJson
  })

  return (
    <React.Fragment>
      <IdealEditor
        {...idealEditorPropsExceptOnSubmit}
        onSubmit={getOnSubmit(closeDialog)}
      />
      <button onClick={getOnSubmit(jest.fn())}>
        Apply
      </button>
    </React.Fragment>
  )
}

function addGenerators(generators: string[]): void {
  const addGeneratorButton = screen.getByText("Add a generator")
  generators.forEach((generator, index) => {
    fireEvent.click(addGeneratorButton)
    const input = screen.getByTestId(`IdealEditorItem-input-${index}`)
    fireEvent.input(input, { target: { value: generator } })
  })
}

export type ApplyMethod = "button" | "enter"

async function apply(applyMethod: ApplyMethod = "button", enterIndex: number = 0): Promise<void> {
  switch (applyMethod) {
    case "button": {
      const applyButton = screen.getByText("Apply")
      fireEvent.click(applyButton)
      return
    }
    case "enter": {
      const input = screen.getByTestId(`IdealEditorItem-input-${enterIndex}`)
      await userEvent.type(input, "{enter}")
      return
    }
    default:
      throw new ExhaustivityError(applyMethod)
  }
}

describe("IdealEditorTestContainer", () => {
  test("empty text as generator", async () => {
    const testContainerProps: TestContainerProps = {
      useIdealEditorArgs: {
        validateGenerator: jest.fn().mockResolvedValue(true),
        validateGeneratorArray: jest.fn().mockResolvedValue(true),
      },
      closeDialog: jest.fn(),
    }
    render(<IdealEditorTestContainer {...testContainerProps}/>)

    addGenerators([""])
    await apply()

    expect(await screen.findByRole("alert")).toContainHTML("Please enter the generator.")
  })

  test("ideal generated by x", async () => {
    const closeDialog = jest.fn()
    const testContainerProps: TestContainerProps = {
      useIdealEditorArgs: {
        validateGenerator: jest.fn().mockResolvedValue(true),
        validateGeneratorArray: jest.fn().mockResolvedValue(true),
      },
      closeDialog,
    }
    render(<IdealEditorTestContainer {...testContainerProps}/>)

    addGenerators(["x"])
    await apply()

    expect(closeDialog).toHaveBeenCalled()

    await waitFor(() => {
      expect(screen.queryByRole("alert")).not.toBeInTheDocument()
    })
  })

  for (const count of [1, 2]) {
    test(`submit with enter at index ${count - 1}`, async () => {
      const closeDialog = jest.fn()
      const testContainerProps: TestContainerProps = {
        useIdealEditorArgs: {
          validateGenerator: jest.fn().mockResolvedValue(true),
          validateGeneratorArray: jest.fn().mockResolvedValue(true),
        },
        closeDialog,
      }
      render(<IdealEditorTestContainer {...testContainerProps}/>)

      addGenerators([...Array(count).keys()].map((n) => `x${n}`))
      await apply("enter", count - 1)

      expect(closeDialog).toHaveBeenCalled()

      await waitFor(() => {
        expect(screen.queryByRole("alert")).not.toBeInTheDocument()
      })
    })
  }

  test("parse error", async () => {
    const errorMessage = "This is an error message for test."
    const testContainerProps: TestContainerProps = {
      useIdealEditorArgs: {
        validateGenerator: jest.fn().mockResolvedValue(errorMessage),
        validateGeneratorArray: jest.fn().mockResolvedValue(true),
      },
      closeDialog: jest.fn(),
    }
    render(<IdealEditorTestContainer {...testContainerProps}/>)

    addGenerators(["x"])
    await apply()

    await waitFor(() => {
      expect(screen.getByRole("alert")).toContainHTML(errorMessage)
    })
    expect(await screen.findByRole("alert")).toContainHTML(errorMessage)
  })

  test("global error", async () => {
    const errorMessage = "This is an error message for test."
    const testContainerProps: TestContainerProps = {
      useIdealEditorArgs: {
        validateGenerator: jest.fn().mockResolvedValue(true),
        validateGeneratorArray: jest.fn().mockResolvedValue(errorMessage),
      },
      closeDialog: jest.fn(),
    }
    render(<IdealEditorTestContainer {...testContainerProps}/>)

    addGenerators(["x"])
    await apply()

    await waitFor(() => {
      expect(screen.getByRole("alert")).toContainHTML(errorMessage)
    })
    expect(await screen.findByRole("alert")).toContainHTML(errorMessage)
  })
})
