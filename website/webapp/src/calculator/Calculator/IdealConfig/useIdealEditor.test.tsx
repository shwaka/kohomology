import { Fragment, useState, ReactElement } from "react"


import { ExhaustivityError } from "@site/src/utils/ExhaustivityError"
import { render, screen, waitFor } from "@testing-library/react"
import userEvent, { UserEvent } from "@testing-library/user-event"
import * as R from "remeda"

import { useIdealEditor, UseIdealEditorArgs } from "./useIdealEditor"

type TestContainerProps = {
  useIdealEditorArgs: Omit<UseIdealEditorArgs, "idealJson" | "setIdealJson">
  closeDialog: () => void
}

function TestContainer(
  { useIdealEditorArgs, closeDialog }: TestContainerProps
): ReactElement {
  const [idealJson, setIdealJson] = useState("[]")
  const editor = useIdealEditor({
    ...useIdealEditorArgs,
    idealJson, setIdealJson
  })
  const { getOnSubmit, renderContent } = editor
  const onSubmit = getOnSubmit(closeDialog)

  return (
    <Fragment>
      {renderContent(closeDialog)}
      <button onClick={onSubmit}>
        Apply
      </button>
    </Fragment>
  )
}

async function addGenerators(user: UserEvent, generators: string[]): Promise<void> {
  const addGeneratorButton = screen.getByText("Add a generator")
  for (const [index, generator] of generators.entries()) {
    await user.click(addGeneratorButton)
    if (generator !== "") {
      // user.type does not accept the empty string.
      const input = screen.getByTestId(`IdealEditorItem-input-${index}`)
      await user.type(input, generator)
    }
  }
}

export type ApplyMethod = "button" | "enter"

async function apply(user: UserEvent, applyMethod: ApplyMethod = "button", enterIndex: number = 0): Promise<void> {
  switch (applyMethod) {
    case "button": {
      const applyButton = screen.getByText("Apply")
      await user.click(applyButton)
      return
    }
    case "enter": {
      const input = screen.getByTestId(`IdealEditorItem-input-${enterIndex}`)
      await user.type(input, "{enter}")
      return
    }
    default:
      throw new ExhaustivityError(applyMethod)
  }
}

describe("useIdealEditor", () => {
  test("empty text as generator", async () => {
    const user = userEvent.setup()
    const testContainerProps: TestContainerProps = {
      useIdealEditorArgs: {
        validateGenerator: jest.fn().mockResolvedValue(true),
        validateGeneratorArray: jest.fn().mockResolvedValue(true),
      },
      closeDialog: jest.fn(),
    }
    render(<TestContainer {...testContainerProps} />)

    await addGenerators(user, [""])
    await apply(user)

    expect(await screen.findByRole("alert")).toContainHTML("Please enter the generator.")
  })

  test("ideal generated by x", async () => {
    const user = userEvent.setup()
    const closeDialog = jest.fn()
    const testContainerProps: TestContainerProps = {
      useIdealEditorArgs: {
        validateGenerator: jest.fn().mockResolvedValue(true),
        validateGeneratorArray: jest.fn().mockResolvedValue(true),
      },
      closeDialog,
    }
    render(<TestContainer {...testContainerProps} />)

    await addGenerators(user, ["x"])
    await apply(user, )

    await waitFor(() => {
      expect(closeDialog).toHaveBeenCalled()
    })
    expect(screen.queryByRole("alert")).not.toBeInTheDocument()
  })

  for (const count of [1, 2]) {
    test(`submit with enter at index ${count - 1}`, async () => {
      const user = userEvent.setup()
      const closeDialog = jest.fn()
      const testContainerProps: TestContainerProps = {
        useIdealEditorArgs: {
          validateGenerator: jest.fn().mockResolvedValue(true),
          validateGeneratorArray: jest.fn().mockResolvedValue(true),
        },
        closeDialog,
      }
      render(<TestContainer {...testContainerProps} />)

      await addGenerators(user, R.range(0, count).map((n) => `x${n}`))
      await apply(user, "enter", count - 1)

      await waitFor(() => {
        expect(closeDialog).toHaveBeenCalled()
      })
      expect(screen.queryByRole("alert")).not.toBeInTheDocument()
    })
  }

  test("parse error", async () => {
    const user = userEvent.setup()
    const errorMessage = "This is an error message for test."
    const testContainerProps: TestContainerProps = {
      useIdealEditorArgs: {
        validateGenerator: jest.fn().mockResolvedValue(errorMessage),
        validateGeneratorArray: jest.fn().mockResolvedValue(true),
      },
      closeDialog: jest.fn(),
    }
    render(<TestContainer {...testContainerProps} />)

    await addGenerators(user, ["x"])
    await apply(user)

    await waitFor(() => {
      expect(screen.getByRole("alert")).toContainHTML(errorMessage)
    })
    expect(await screen.findByRole("alert")).toContainHTML(errorMessage)
  })

  test("global error", async () => {
    const user = userEvent.setup()
    const errorMessage = "This is an error message for test."
    const testContainerProps: TestContainerProps = {
      useIdealEditorArgs: {
        validateGenerator: jest.fn().mockResolvedValue(true),
        validateGeneratorArray: jest.fn().mockResolvedValue(errorMessage),
      },
      closeDialog: jest.fn(),
    }
    render(<TestContainer {...testContainerProps} />)

    await addGenerators(user, ["x"])
    await apply(user)

    await waitFor(() => {
      expect(screen.getByRole("alert")).toContainHTML(errorMessage)
    })
    expect(await screen.findByRole("alert")).toContainHTML(errorMessage)
  })
})
